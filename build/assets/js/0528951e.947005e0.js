"use strict";(self.webpackChunkhackathon_book=self.webpackChunkhackathon_book||[]).push([[456],{2651(e,t,n){n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"module-3/intro","title":"Chapter 1: Introduction & Learning Objectives","description":"Learning Objectives","source":"@site/docs/module-3/01-intro.md","sourceDirName":"module-3","slug":"/module-3/intro","permalink":"/hackathon-book/docs/module-3/intro","draft":false,"unlisted":false,"editUrl":"https://github.com/anthropics/hackathon-book/tree/main/docs/module-3/01-intro.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 3: Sensors & Sim-to-Real Gaps","permalink":"/hackathon-book/docs/module-2/sensors"},"next":{"title":"Chapter 2: Mechanical Structure & Kinematics","permalink":"/hackathon-book/docs/module-3/mechanical"}}');var i=n(4848),s=n(8453);const r={},a="Chapter 1: Introduction & Learning Objectives",c={},l=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction: From Simulation to Physical Robots",id:"introduction-from-simulation-to-physical-robots",level:2},{value:"References",id:"references",level:2}];function d(e){const t={a:"a",em:"em",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",strong:"strong",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"chapter-1-introduction--learning-objectives",children:"Chapter 1: Introduction & Learning Objectives"})}),"\n",(0,i.jsx)(t.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsx)(t.p,{children:"After completing this module, you will be able to:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Explain how mechanical structure constrains control capabilities"})," in humanoid robots \u2014 specifically, how degrees of freedom (DOF), kinematic chains, and gear ratios directly affect control bandwidth, speed, and force capacity."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Describe the roles of multiple sensor modalities"})," (vision, force/torque, IMU, proprioceptive, tactile) and how sensor fusion enables robots to understand their body state and environment simultaneously."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Compare actuator technologies"})," (electric motors, hydraulic systems, Series Elastic Actuators) and justify design trade-offs between power density, compliance, control complexity, and energy efficiency for different humanoid applications."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Analyze real-time compute architecture"})," \u2014 understanding why CPU handles control loops (hard deadlines), GPU handles perception, and how edge AI placement affects latency and power budgets."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Design a ROS 2 software stack"})," for humanoid control, including node architecture, real-time publish-subscribe patterns, and sensor-actuator feedback loops that respect hardware latencies."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Identify safety mechanisms"})," (mechanical, electrical, software) and explain how redundancy and fail-safe design integrate across all subsystems to protect against catastrophic failures."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"introduction-from-simulation-to-physical-robots",children:"Introduction: From Simulation to Physical Robots"}),"\n",(0,i.jsx)(t.p,{children:"In Module 2, we built digital twins of humanoid robots in Gazebo, learning how physics engines simulate contact, friction, and dynamics. We explored sim-to-real gaps: the differences between perfect simulation and messy physical reality. Now in Module 3, we shift perspective from virtual worlds to actual machines."}),"\n",(0,i.jsx)(t.p,{children:"A humanoid robot is not just a software problem. It is a tightly integrated system where mechanical design, sensing, actuation, computation, and control must work in concert. Every architectural decision \u2014 from the number of joints to the type of motor \u2014 creates constraints and enablers that propagate through the entire system."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"This module explores system-level architecture: how do we integrate mechanical structure, sensors, actuators, and compute to create a robot that can walk, manipulate objects, and adapt to unexpected disturbances?"})," Understanding this integration is critical for Module 4 (control algorithms), where we will implement controllers that must respect the hardware constraints you learn here. It is equally critical for Module 5 (AI integration), where machine learning systems must operate within power budgets and latency bounds set by the architecture."]}),"\n",(0,i.jsxs)(t.p,{children:["We will use Boston Dynamics Atlas as our case study \u2014 a 28-degree-of-freedom hydraulic humanoid that has set records for dynamic locomotion and object manipulation. By the end of this module, you will understand ",(0,i.jsx)(t.em,{children:"why"})," Atlas was designed the way it is, and how its architecture enables its extraordinary capabilities."]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"references",children:"References"}),"\n",(0,i.jsxs)(t.p,{children:["Boston Dynamics. (2023). Atlas Robot Specifications and Documentation. Retrieved from ",(0,i.jsx)(t.a,{href:"https://www.bostondynamics.com/",children:"https://www.bostondynamics.com/"})]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453(e,t,n){n.d(t,{R:()=>r,x:()=>a});var o=n(6540);const i={},s=o.createContext(i);function r(e){const t=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),o.createElement(s.Provider,{value:t},e.children)}}}]);